# Critical assessment of project and lessons learned:

This project was found by using the Github search functionality, filtering for projects tagged as being written in JavaScript and "javascript-game" as an additional tag. I have some experience in game development but little experience with vanilla javascript, so my search philosophy was to find something which could be easily run and observed, so that incremental changes could be easily tested. Scrolling through projects there was an obvious stratification in terms of repository popularity and type. The main observed categories were personal and educational. Small hobby projects with one or two contributors and no stars or forks made up the bulk. Educational or "walk-through" repositories also had few contributors but many stars and forks. I avoided educational repos and instead investigated personal projects to get a better sense of "real" projects as walkthrough projects sometimes have an unrealistic structure.

The ability to immediately fork the project and begin work is one of the best features of working with GitHub and an interesting byproduct of just how ubiquitous the platform has become for hosting open-source development. The convenience and opportunities it provides especially in the educational context of this project are invaluable. More specifically I have learned interesting aspects of using vanilla javascript for the development of dynamic in-browser games from a developer who does not know me and likely had no direct intention for their project to end up as educational material for another. In this way the convenient forking process serves as a way for projects to be used in new and useful ways that the original developers could not have foreseen, not just to crowd-source improvements and oversight which are often considered the main purpose of public OSS hosting.

The game Black Hole Square (this project) was chosen for its uniqueness and at a glance the game mechanics seemed appropriate in scope and the code appeared well-structured.

Assessing the project initially, it is clearly well-conceived, well-scoped and well-executed. Project code is nicely split into sensible files, functions, and components which avoids reuse and makes clever use of JSON to define game "boards".

The project does however exhibit the most common pitfall of a hobby project created under competition conditions, which make open-source development of this project more difficult.

That pitfall is of course that there are almost no comments throughout the code. Critically there are no docstrings for functions or modules which makes it hard for a fresh developer to understand the broader function or purpose of large chunks of uncommented code. Where there are comments they are concise and descriptive, and so it becomes clear that the developer's intent was clean, readable code but for whatever reason (most likely time pressure) documentation was left out in favour of pushing functionality and finishing/improving the code itself for production/submission. This extends (less critically) to the project repository itself where there are no running or contribution instructions. A license for use was added recently after a period of inactivity on the project so it is possible there are plans to improve this. Part of my improvement to the project was to include the basic instructions for running and making changes to the game.

Making improvements initially seemed like a daunting task. There were many ideas in the notebook of course, it's usually fairly easy to conceive of ways to improve or expand the functionality of a game not to mention any app. Similar to the scope-creep that happens while conceiving of a product, confirming appropriate areas of improvement needs to be balanced with an assessment of the resources available to those making the improvements.

The most valuable improvement conceived and implemented was adding support for the mouse scroll-wheel to navigate the game's levels. This was an improvement purely from the perspective of the user and has the most pronounced impact on the user's experience. While cleaning up a project for other developers is valuable, I think it's important to remember why a piece of software exists in the first place and that is to serve its function effectively. In this case, the added feature improves accessibility and ease of use for the actual target of the product.

Making improvements intended for other developers to "slot in" is an area which is a bit more controversial in open source software. Many conceived improvements to this project would come under a "configuration" or "settings" umbrella. The time to implement these changes however was beyond the scope of this sprint, and so the functionality was pared down to just the menu in which these future features could be implemented. In theory I think this opens the door for better crowd-sourced improvements which benefits the product, despite the fact that it introduces "unfinished" elements to a distributed product. As long as the unfinished aspects don't negatively impact the user then I believe that promoting future work for other developers adds value to a project.

While additional functionality is an obvious choice for aiding in open-source development (we want to write code!), a more thankless task is cleaning up code smells, potential problems and bugs. Initially I mostly ignored the strange "monetisation" code that popped up when loading game entities. It definitely bothered me and I was almost certain there was no real implementation of any kind of monetisation in this project, but without any documentation or code comments I wasn't sure if this code needed to stay where it was for some other reason. Eventually following the trail of this check for "payed" status by the user through the project files I decided that it was safe to remove, but this should not have been a task as arduous as it was with proper documentation.

Overall the experience was unsurprisingly more tedious than working on a familiar project or features from scratch, it can be difficult to "grok" an unfamiliar codebase especially of this size considering time constraints. Conversely this hard learning process is great for being introduced to interesting code patterns, and every improvement made feels like it is helping someone else achieve a vision you may never have had yourself, making each commit a lot more satisfying.